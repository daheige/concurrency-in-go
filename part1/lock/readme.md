# 死锁，活锁和锁的饥饿问题
    我将从如下3个方面剖析
    1. 死锁
    2. 活锁
    3. 锁的饥饿问题

# 死锁
    死锁是所有并发进程都在彼此等待的状态。 在这种情况下，如果没有外部干预，程序将永远不会恢复。
    如果这听起来很严峻，那是因为它确实很严峻！ Go运行时会检测到一些死锁（所有的例程必须被阻塞或“休眠”），但这对于帮助你防止死锁产生没有多大帮助

# 出现死锁需满足的条件
    出现僵局时必定存在一些条件，1971年，埃德加科夫曼在一篇论文中列举了这些条件。这些条件现在称为科夫曼条件，是帮助检测，防止和纠正死锁的技术基础。

    科夫曼条件如下：

    相互排斥
    并发进程在任何时候都拥有资源的独占权。

    等待条件
    并发进程必须同时持有资源并等待额外的资源。

    没有抢占
    并发进程持有的资源只能由该进程释放，因此它满足了这种情况。

    循环等待
    并发进程（P1）等待并发进程（P2），同时P2也在等待P1，因此也符合"循环等待"这一条件

# 解决死锁的方法
    科夫曼条件同样有助于我们规避死锁。如果我们确保至少有一个条件不成立，就可以防止发生死锁。不幸的是，实际上这些条件很难推理，因此难以预防。网上大量充斥着被死锁困扰的开发人员的求助，一旦有人指出它就很明显，但通常需要另一双眼睛

# 活锁(livelock.go)
    活锁是正在主动执行并发操作的程序，但这些操作无法向前移动程序的状态。

    你有没有在走廊走向另一个人？ 她移动到一边让你通过，但你也是这样做的。 所以你转移到另一边，但她也是这样做的。 想象这会永远持续下去，这就是活锁

# 死锁和活锁的区别
    在我看来，活锁比死锁更难以发现，因为它看起来好像程序正在工作。 如果活锁程序在你的机器上运行，并且你查看了CPU利用率以确定它是否在执行任何操作，那么你可能会认为它是。 根据活锁的不同，它甚至可能会发出其他信号，使你认为它正在工作。 然而，一直以来，你的程序都扮演着走廊洗牌的永恒游戏。






