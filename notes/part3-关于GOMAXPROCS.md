# 关于GOMAXPROCS
    在runtime包中，有一个方法是GOMAXPROCS。在我看来，这个函数名有点误导人：人们经常认为这个函数与主机上逻辑处理器的数量有关， 但是这个函数真正控制着将要托管所谓的“工作队列”的操作系统线程的数量。在第6章我们会讨论关于它的更多详细信息。

    在Go 1.5之前，GOMAXPROCS总是设置为1，通常你会在大多数Go程序中找到这个片段：

    runtime.GOMAXPROCS(runtime.NumCPU())
    几乎所有的开发人员都希望利用其进程能够使用计算机上的所有内核。因此，在随后的Go版本中，它被自动设置为主机上的逻辑CPU数量。

    那么，如果你想调整这个值呢？ 大多数时候你尽量别这么想。Go的调度算法在大多数情况下足够好，即增加或减少工作队列和线程的数量可能会造成更多的伤害，但仍然有些情况下可能会更改此值。

    例如，我曾经参与过一个项目，该项目有一个受竞争条件困扰的测试套件。事实上，该团队有一些测试包有时会失败。我们运行测试的基础架构只有四个逻辑CPU，因此在任何一个时间点，我们都有四个goroutines同时执行。 通过增加GOMAXPROCS超过我们所拥有的逻辑CPU数量，我们能够更频繁地触发竞态条件，从而更快地纠正它们。

    有人可能会通过实验发现，他们的程序在一定数量的工作队列和线程下运行得更好，但我敦促谨慎行事。如果你通过调整CPU来压缩性能，请务必在每次提交后，使用不同硬件以及使用不同版本的Go时执行此操作。调整这个值是以更高的抽象和长期性能稳定性的降低为代价的。
